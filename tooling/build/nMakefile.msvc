#### MSVC Jumpstart Makefile, new gen., WIP
#### -> https://github.com/xparq/NMAKE-Jumpstart
####
#### BEWARE! Uses recursive NMAKE invocations, so update the macro below if
#### you rename this file:
THIS_MAKEFILE=tooling\build\nMakefile.msvc
#
# NOTE: Custom macros can't be set on the NMAKE command line, only here, because
#       the recursion won't pass them along, unless added to $custom_build_options!
#

BBB_VERBOSE=1	# 0 .. 4
# Parts of the build procedure can be skipped:
BBB_SKIP_CONFIGURE=0
BBB_SKIP_BUILD=0

#-----------------------------------------------------------------------------
# Config - Project layout
#-----------------------------------------------------------------------------
PRJ_NAME=$(SZ_APP_NAME)
# Use the lower-case (processed) path macros here:
#main_lib=$(lib_dir)/$(PRJ_NAME)$(buildmode_suffix).lib
main_exe=$(exe_dir)/$(PRJ_NAME)$(buildmode_suffix).exe
# Main targets to build:
BUILD = $(main_lib) $(main_exe)

SRC_DIR=$(SZ_SRC_SUBDIR)
OUT_DIR=$(SZ_OUT_SUBDIR)
LIB_DIR=$(OUT_DIR)
EXE_DIR=$(SZ_RUN_SUBDIR)
OBJ_DIR=$(OUT_DIR)/obj
#!! This won't work as expected: both $(obj_dir) and then the ifc dir both get
#!! prefixed, resulting in ././ at best, already failing a ./ inference rule!... :-o
#!!IFC_DIR=$(obj_dir)
IFC_DIR=$(OUT_DIR)
# Put (only) these into the lib (relative to SRC_DIR; leave it empty for "all"):
LIB_SRC_SUBDIR=

# Source (translation unit) basename filter (CMD shell glob pattern):
UNITS_PATTERN=*
# Ignore-filter on full-path source names -> NMAKE `filterout` pattern list syntax!
# Multiple patterns must be separated by spaces. Do NOT quote the list!
UNITS_NO_COMPILE_PATTERN=.off .tmp
# Ignore-filter on full-path source names -> `findstr` REGEX syntax!
# Multiple patterns must be separated by spaces. Do NOT quote the list!
UNITS_NO_LINK_PATTERN=\.off \.tmp sz[/\\]test counter.obj
UNITS_NO_LIB_PATTERN=$(UNITS_NO_LINK_PATTERN)

#!! Sigh... No header autodep... And no unified obj list either to use as a target! :-/
#!! Also, must use a fixed path (not necessary absolute, but definitely not just .),
#!! or else the filenames/patterns would be mistakenly applied to the current subdir,
#!! and MAKE would fail with "dunno how to make..."
#!! Also, must NOT use $(src_dir) $(src_dir_abspath) here, as those will also point
#!! to the current node of the source tree, not its root! :-o
OBJ_DEPS_manually=$(SRC_DIR)/*.hpp $(SRC_DIR)/_build_cfg.h \
	$(SRC_DIR)/Model/*.hpp \
	$(SRC_DIR)/View/*.hpp \
	$(SRC_DIR)/UI/*.hpp \
	$(SRC_DIR)/UI/adapter/SFML/*.hpp \
#	$(SRC_DIR)/Platform/*.hpp \
	$(SRC_DIR)/adapter/SFML/*.hpp \
	$(SRC_DIR)/sz/*.hh \

#
# External dependencies:
#
EXT_INCLUDE_DIRS=
EXT_LIB_DIRS=

EXT_LIB_SFW=extern/sfw/lib/msvc/sfw$(_cflags_crt_linkmode)$(_buildmode_debug_file_suffix).lib
EXT_LIB_ZSTD=extern/zstd/msvc/zstd$(_cflags_crt_linkmode).lib
EXT_LIBS=\
	$(SZ_SFML_ROOT)/lib/$(sfml_and_deps_libs) \
	$(EXT_LIB_SFW) \
	$(EXT_LIB_ZSTD) \
	user32.lib
#		^^^ Only needed with SFML=dll, strangely! -o
#	extern/toml++/toml$(_cflags_crt_linkmode).lib \

#-----------------------------------------------------------------------------
# Config - Build options
#-----------------------------------------------------------------------------
# Build alternatives (override from the command-line, too, if needed):
DEBUG=0
CRT=static
#!Sz: CRT=dll is always the case with the pre-built SFML libs, so not use changing it!
# Custom build options can also be added:
SFML=static
# Custom build options need to be passed along for recursion explicitly:
custom_build_options = SFML=$(SFML) BBB_VERBOSE=$(BBB_VERBOSE)

# Custom Tools:
#!Sz: Assuming being called from a script that has already set the path:
SH = "C:\Program Files\Git\bin\sh.exe"
#SH = busybox sh
ECHO=@echo
#! Unnecessary:
#MKDIR=$(BB) mkdir -p

# Comp. flags:
CFLAGS=-W4 -Iinclude
CXXFLAGS=-std:c++latest
# Note: C++ compilation would use $(CFLAGS), too.

# Output dir/file suffixes for build alternatives
# NOTE: Must differ from their "no ..." counterparts to avoid code (linking)
#       mismatches!
#!Sz: CRT=dll is always the case with the pre-built SFML libs, so not use changing it! (See also at CRT=...)
buildmode_crtdll_dir_suffix=.crtdll
buildmode_crtdll_file_suffix=-crtdll
buildmode_debug_dir_suffix=.DEBUG
buildmode_debug_file_suffix=-d

SFML_linkmode=$(SFML)
buildmode_dir_suffix=.sfml-$(SFML_linkmode)

#!-------------------------------------
#!Sz Other custom options for OON...
#!-------------------------------------
CFLAGS=$(CFLAGS) -DBACKEND=SFML
#CFLAGS=$(CFLAGS) -DGFX_BACKEND=... -DINPUTS_BACKEND=... -DAUDIO_BACKEND=... -DSYSTEM_BACKEND=...

!if "$(SFML)" == "static"
CFLAGS=$(CFLAGS) -DSFML_STATIC
!endif
CXXFLAGS=-std:c++latest -utf-8 -Zc:preprocessor
# Add a -I also for including the commit hash file:
CFLAGS=$(CFLAGS) -I$(out_dir)
# Add a -I also for 'extern' (perhaps redundantly, as the env should have it, but it's so generic):
CFLAGS=$(CFLAGS) -Iextern

# Note: C++ comp. commands would use $(CFLAGS), too! (!!Which may be stupid, and change later...!!)

# Adapt the various flavors of the SFML libs (as per the debug/link modes)...
!if "$(CRT)" == "static"
_sfMT = -s
sfml_libs_static = sfml-graphics-s$(_sfMT).lib sfml-window-s$(_sfMT).lib sfml-system-s$(_sfMT).lib sfml-audio-s$(_sfMT).lib
!else
sfml_libs_static = sfml-graphics-s.lib sfml-window-s.lib sfml-system-s.lib sfml-audio-s.lib
!endif

sfml_libs_dll = sfml-graphics.lib sfml-window.lib sfml-system.lib sfml-audio.lib

!if "$(SFML)" == "static"
sfml_libs=$(sfml_libs_static)
sfml_and_deps_libs=$(sfml_libs) opengl32.lib freetype.lib\
	ogg.lib vorbis.lib vorbisenc.lib vorbisfile.lib flac.lib openal32.lib \
	user32.lib kernel32.lib gdi32.lib winmm.lib advapi32.lib
!else if "$(SFML)" == "dll"
sfml_libs=$(sfml_libs_dll)
sfml_and_deps_libs=$(sfml_libs) opengl32.lib
!endif

!if defined(DEBUG) && $(DEBUG) == 1
sfml_libs=$(substi .lib,-d.lib,$(sfml_libs))
!endif

#=============================================================================
#                     NO EDITS NEEDED BELOW, NORMALLY...
#=============================================================================
obj_source_exts=ixx c cpp cxx cc
obj_source_exts_dotted=$(patsubst %,.%,$(obj_source_exts))


#-----------------------------------------------------------------------------
# Normalize the (prj-local) paths before potentially passing them to any of
# the arcane "DOS" commands only to make them choke on fwd. slashes!...
# + Also guard against accidental \ prefixes for empty dirs!
#   (Note: \ needs to be escaped here. Quoted paths are NOT handled here,
#   because those couldn't be used later anyway for appending subdirs, so
#   quoting is assumed to be handled at the last moment, when passing the
#   paths to commands!)
#-----------------------------------------------------------------------------
#! Not prefixdir=$(MAKEDIR), as most of these are subdirs!
#! Also: abspath'ed, so that user code doesn't have to worry about accidental
#! crosstalk between relative subdir macros like ($src_dir) across multiple
#! recursive runs for the indivirual source subdirs!... :-o
prefixdir=.
#! This is still too hamfisted if some were in fact ment to be absolute paths!
#! Anyway, at leat it's erring on the safe side.
src_dir         = $(prefixdir)\$(patsubst \\%,%,$(SRC_DIR:/=\))
out_dir         = $(prefixdir)\$(patsubst \\%,%,$(OUT_DIR:/=\))
lib_dir         = $(prefixdir)\$(patsubst \\%,%,$(LIB_DIR:/=\))
exe_dir         = $(prefixdir)\$(patsubst \\%,%,$(EXE_DIR:/=\))
obj_dir         = $(prefixdir)\$(patsubst \\%,%,$(OBJ_DIR:/=\))
ifc_dir         = $(prefixdir)\$(patsubst \\%,%,$(IFC_DIR:/=\))
#! These are assumed to have been prefixed with some dirs already,
#! but if still not, they'll just go to the current dir:
!if "$(main_lib)" != ""
main_lib        =              $(patsubst \\%,%,$(main_lib:/=\))
!endif
!if "$(main_exe)" != ""
main_exe        =              $(patsubst \\%,%,$(main_exe:/=\))
!endif
# And this one is really a subdir, which will be prefixed internally with src_dir,
# so don't mess it up with the same adjustment, just normalize the slashes:
lib_src_subdir  = $(LIB_SRC_SUBDIR:/=\)

# Now, this one, OTOH, must be the normalized *full* path of the src root:
#   src_dir_abspath = $(MAKEDIR)\$(src_dir)
# -- used in the command blocks for abs->rel conversion (via direct path
# string replacement in the tree traversal loops), which needs to be as
# robust as possible! (And are still too brittle!...)
# Except...: if the path contains spaces, then it's considered a list,
# and each item would get separately normalized! (Quoting doesn't help! :-/ )
# So... Behold this shameless abomination of a workaround:
_SPACE_=$(subst x,,x x)
p=$(subst $(_SPACE_),<FAKE_SPACE>,$(MAKEDIR)\$(src_dir))
src_dir_abspath=$(subst <FAKE_SPACE>,$(_SPACE_),$(abspath $(p)))


#-----------------------------------------------------------------------------
# Set/adjust tool options (according to the config)...
#-----------------------------------------------------------------------------
# Preserve the original NMAKE flags & explicitly supported macros on recursion:
NMAKE_RECURSE_CMD=$(MAKE) /nologo /$(MAKEFLAGS) /f $(THIS_MAKEFILE) DEBUG=$(DEBUG) CRT=$(CRT)

CFLAGS=-nologo -c $(CFLAGS)
CXXFLAGS=-EHsc $(CXXFLAGS)
!if "$(ifc_dir)" != ""
CXXFLAGS=-ifcSearchDir $(ifc_dir) $(CXXFLAGS)
!else
!error ifc_dir is not set?!
!endif

#----------------------------
# Static/DLL CRT link mode
#------
!if "$(CRT)" == "static"
_cflags_crt_linkmode=-MT
!else if "$(CRT)" == "dll"
_cflags_crt_linkmode=-MD
!else
!error Unknown CRT link mode: $(CRT)!
!endif

#----------------------
# DEBUG/RELEASE mode
#------
cflags_debug_0=$(_cflags_crt_linkmode) -O2 -DNDEBUG
cflags_debug_1=$(_cflags_crt_linkmode)d -ZI -Od -Oy- -Ob0 -RTCsu -DDEBUG -Fd$(out_dir)/
	# The -O...s above are borrowed from Dr. Memory's README/Quick start.
	# -ZI enables edit-and-continue (but it only exists for Intel CPUs!).
linkflags_debug_0=
linkflags_debug_1=-debug -incremental -editandcontinue -ignore:4099

!if defined(DEBUG) && $(DEBUG) == 1
_cflags_debugmode=$(cflags_debug_1)
_linkflags_debugmode=$(linkflags_debug_1)
!else if $(DEBUG) == 0
_cflags_debugmode=$(cflags_debug_0)
_linkflags_debugmode=$(linkflags_debug_0)
!else
!error Unknown debug mode: $(DEBUG)!
!endif

CFLAGS=$(_cflags_debugmode) $(CFLAGS)
LINKFLAGS=$(_linkflags_debugmode) $(LINKFLAGS)

#---------------------------------------
# Update the INCLUDE & LIB env. vars for external tools
#------
!if "$(EXT_INCLUDE_DIRS)" != ""
!if [set INCLUDE=%INCLUDE%;$(EXT_INCLUDE_DIRS)]
!endif
!endif

!if "$(EXT_LIB_DIRS)" != ""
!if [set LIB=%LIB%;$(EXT_LIB_DIRS)]
!endif
!endif
# Or, alternatively:
#!if "$(EXT_LIB_DIRS)" != ""
#LINKFLAGS=$(LINKFLAGS) -libpath:$(EXT_LIB_DIRS)
#!endif

#-----------------------------------------------------------------------------
# Split the target tree across build alternatives...
#!! Would be nice to just split the root, but the libs and exes can be
#!! off the tree (for convenience & flexibility, e.g. differentiated by name
#!! suffixes etc.)... Which leaves us with dispatching the obj_dir instead
#!! -- and leaving the lib_dir and exe_dir totally ignored... :-/
#-----------------------------------------------------------------------------
# For the output dirs (currently only the obj. dir), and
# for the output files (currently the lib/exe files)
!if "$(CRT)" == "dll"
buildmode_dir_suffix=$(buildmode_dir_suffix)$(buildmode_crtdll_dir_suffix)
buildmode_file_suffix=$(buildmode_file_suffix)$(buildmode_crtdll_file_suffix)
!endif

!if "$(DEBUG)" == "1"
_buildmode_debug_file_suffix=$(buildmode_debug_file_suffix)
_buildmode_debug_dir_suffix=$(buildmode_debug_dir_suffix)
buildmode_dir_suffix=$(buildmode_dir_suffix)$(buildmode_debug_dir_suffix)
buildmode_file_suffix=$(buildmode_file_suffix)$(buildmode_debug_file_suffix)
!endif

obj_dir=$(obj_dir)$(buildmode_dir_suffix)

#-----------------------------------------------------------------------------
# Adjust paths for the inference rules, according to the current subdir-recursion
#-----------------------------------------------------------------------------
!if "$(DIR)" != ""
src_dir=$(src_dir)\$(DIR)
obj_dir=$(obj_dir)\$(DIR)
!endif

#-----------------------------------------------------------------------------
!if $(BBB_VERBOSE) < 1
_mute=@
!else
_mute=
!endif



#-----------------------------------------------------------------------------

#...

#!! SADLY...:
#!!
#!! We cannot construct the obj target list from the local sources (see compile_dir...), because
#!! NMAKE can only process wildcards on rule lines, where it's too late for this... :-/
#!!local_objs = $(no wildcard function!... )
#!!
#
# Trigger the inference rules by changed headers, too!...
#$(local_objs) : $(OBJ_DEPS_manually)


#=============================================================================
# Rules...
#=============================================================================

# This rule is implicitly selected as the default target on the first run:
default: export_cfg bootstrap

export_cfg:
# Some of these macros may well have come from the same env. vars in the first place,
# but they as well may not... If they have, no harm done by redundantly setting
# them back to their (well, roughly...) original values.
# Casing (i.e. NMAKE's auto toupper conv.) may be a problem though; define & doc. them properly!!
	@set BBB_MAIN_MAKEFILE=$(THIS_MAKEFILE)
	@set BBB_NMAKE_RECURSE_CMD=$(NMAKE_RECURSE_CMD)
	@set BBB_MAKEFLAGS=$(MAKEFLAGS)
	@set BBB_VERBOSE=$(BBB_VERBOSE)
	@set BBB_SKIP_CONFIGURE=$(BBB_SKIP_CONFIGURE)
	@set BBB_SKIP_BUILD=$(BBB_SKIP_BUILD)
#!! This should contain all the macros passed to the nmake cmdline:
#!!	@set BBB_BUILD_CMD_OPTS=$(...all_build_options_for_cmdline)
	@set BBB_BUILD_OPT_DEBUG=$(DEBUG)
	@set BBB_BUILD_OPT_CRT=$(CRT)
	@set BBB_CUSTOM_BUILD_OPTS=$(custom_build_options)
	@set PRJ_ROOT=$(PRJ_ROOT)
	@set OUT_DIR=$(out_dir)
	@set OBJ_ROOT=$(obj_dir)
	@set SRC_ROOT=$(src_dir)
	@set IFC_ROOT=$(ifc_dir)
	@set OBJ_SRC_EXTS=$(obj_source_exts_dotted)
	@set UNITS_NO_COMPILE_PATH_PATTERN=$(UNITS_NO_COMPILE_PATH_PATTERN)
	@set UNITS_NO_LINK_PATTERN=$(UNITS_NO_LINK_PATTERN)

bootstrap:
#	@cmd /c ..\NMAKE-Jumpstart\study\BBB\tooling\build\brutebuild-TEMPLATE.cmd
#	@findstr FAIL4f3g4 <<$(out_dir)\bbb.cmd || echo [BBB: THE BUILD PREP. SCRIPT HAS BEEN LINKED, NOT EMBEDDED!]
	@cmd /c <<$(out_dir)\bbb.cmd
@echo off
setlocal EnableExtensions
setlocal EnableDelayedExpansion

::call :_setd_test
::exit

call :setd BBB_VERBOSE "%1"
call :setd BBB_VERBOSE 1
::	0 - 4

call :setd BBB_SKIP_CONFIGURE 0
call :setd BBB_SKIP_BUILD 0

::============================================================================
:: CONFIG
::============================================================================
:: We expect to be in the project dir, but it can also be set to something
:: (else) explicitly:
::!!NOT WELL-TESTED!!
call :setd PRJ_ROOT .

:: These are relative to PRJ_ROOT:
call :setd SRC_ROOT src
call :setd OUT_DIR build.out
call :setd OBJ_ROOT %OUT_DIR%\obj
call :setd IFC_ROOT %OUT_DIR%\ifc

::!! This should morph into a higher-level type-wise iteration control to allow
::!! doing different things for different source types...:
call :setd OBJ_SRC_EXTS ".ixx .c .cpp .cc .cxx"

:: Ignore-filter (applied to source file full paths) -> NMAKE `filterout` pattern list syntax!
:: Multiple patterns must be separated by spaces.
call :setd UNITS_NO_COMPILE_PATTERN ".off .tmp"

:: Ignore-filter on full-path source names -> `findstr` REGEX syntax!
:: Multiple patterns must be separated by spaces. Do NOT quote the list!
::
::!!?? WHY DOES FINDSTR TREAT THESE AS REGEXES EVEN WITH /L????????? :-ooooooooooooo
::!! Alas, no nice link-time path filering when OBJ_DIR_FLAT... :-/
::!!set UNITS_NO_LINK_PATTERN=\.off \.tmp sz[/\\]test counter.obj
call :setd UNITS_NO_LINK_PATTERN "\.off \.tmp"
::
call :setd UNITS_NO_LIB_PATTERN "%UNITS_NO_LINK_PATTERN%"


set BATCH_COMPILE=on
::set OBJ_DIR_FLAT=1
	::!! No support for tree modes (normal per-file vs. batched-per-dir) yet!

if %BBB_VERBOSE% GEQ 4 (
	echo BBB_VERBOSE: [%BBB_VERBOSE%]
	echo PRJ_ROOT: [%PRJ_ROOT%]
	echo OBJ_SRC_EXTS: [%OBJ_SRC_EXTS%]
)

::============================================================================
:: ENGINE
::============================================================================
:: Mind the _double_ empty lines after this one... It's crucial:
set LF=^


set "TAB=	"

:: Since this can't be reliably detected (with a sane effort), it must be set
:: by whoever has called us:
if not defined BBB_MAIN_MAKEFILE (
	set BBB_MAIN_MAKEFILE=Makefile
	echo - WARNING: Makefile has not been set, assuming "%BBB_MAIN_MAKEFILE%"...
	pause
)

:: Propagate the original make option macros:
if not defined BBB_NMAKE_RECURSE_CMD (
	set "BBB_NMAKE_RECURSE_CMD=nmake /nologo /f %BBB_MAIN_MAKEFILE%"
	echo - WARNING: BBB_NMAKE_RECURSE_CMD not set, conjuring up "%BBB_NMAKE_RECURSE_CMD%"
	echo            ANY CUSTOM OPTIONS PASSED TO THE ORIGINAL nmake COMMAND WILL BE LOST!
	echo            So, this is basically an error. But let's see the world collapse! ;-p
	pause
)

::!! This should already be baked into BBB_NMAKE_RECURSE_CMD by the makefile,
::!! but that's not yet implemented... :-/
:: Propagate the original make option macros:
set "BBB_BUILD_CMD_OPTS=!BBB_BUILD_CMD_OPTS! %BBB_CUSTOM_BUILD_OPTS%
::echo BBB_BUILD_CMD_OPTS: [%BBB_BUILD_CMD_OPTS%]
set BBB_NMAKE_RECURSE_CMD=!BBB_NMAKE_RECURSE_CMD! %BBB_BUILD_CMD_OPTS%
::echo BBB_NMAKE_RECURSE_CMD: [%BBB_NMAKE_RECURSE_CMD%]
::pause

:: Force flat obj dirs (!!should only be done in batch-compile mode!...)
set OBJ_DIR_FLAT=1
	::!! Well, non-flat doesn't work with batch mode: MSVC can't put objects
	::!! into different subdirs, they all must go to the same /Fo dir!

set "prj_root=%PRJ_ROOT%"
call :addslash prj_root_ "%prj_root%"
call :addslash out_dir_  "%OUT_DIR%"

::!! This would incorrectly add PRJ_ROOT *AGAIN*, if we got them cooked!
::!! SPECIFY WHAT ACTUALLY IS THE REQUIREMENT!...
::!!set "src_dir=%prj_root_%%SRC_ROOT%"
::!!set "obj_dir=%prj_root_%%OBJ_ROOT%"
set "src_dir=%SRC_ROOT%"
set "obj_dir=%OBJ_ROOT%"
call :addslash src_dir_ "%src_dir%"
call :addslash obj_dir_ "%obj_dir%"

:: "Own" the source tree...
call :check_dir "%src_dir%" src_dir_abs || exit 1
::echo %src_dir% (echo %src_dir_abs%)

:: Obj_dir would be created if missing, later... -- but that's that thing,
:: "later" would be too late! E.g. the obj. list would be created there, and
:: that's gonna happen pretty soon... So, create it now:
call :check_dir "%obj_dir%" obj_dir_abs || MD "%obj_dir%"
call :check_dir "%obj_dir%" obj_dir_abs || exit 1
::echo %obj_dir% (echo %obj_dir_abs%)


set "BBB_MAKEFILE_TEMPLATE=%out_dir_%RoboMake.msvc.mak"

set "dirlist_file=%out_dir_%.src-dirs.tmp"
set "srclist_file=%out_dir_%.src-sources.tmp"
set "objlist_file=%out_dir_%.src-objects.tmp"


::=====================================================================================
::=====================================================================================
::=====================================================================================
::
::   AUTO-CONFIGURE THE BUILD PROCEDURE...
::
::=====================================================================================
::=====================================================================================
::===================================================================================
if %BBB_SKIP_CONFIGURE% EQU 1 goto :skip_configure

::----------------------------------------
:: Collect candidate source subdirs...
::
if "%BBB_VERBOSE%" GEQ "1" echo Preparing to build "%src_dir_abs%"...
:: Add an empty line if more details are expected:
if "%BBB_VERBOSE%" GEQ "2" echo.

	:: .ext list -> *.ext list:
	set "src_ext_patterns=*%OBJ_SRC_EXTS%"
	set "src_ext_patterns=%src_ext_patterns: .= *.%"

call :create_dirlist "%dirlist_file%" "%src_dir%" "%src_ext_patterns%" "%UNITS_NO_COMPILE_PATTERN%"
::	Note: UNITS_NO_COMPILE_PATTERN will only be applied to dir names in this stage!
if "%BBB_VERBOSE%" GEQ "2" echo.

::----------------------------------------
:: Collect candidate source files...
::
if "%BBB_VERBOSE%" GEQ "2" echo Preparing file lists...
if "%BBB_VERBOSE%" GEQ "2" echo.
if "%BBB_VERBOSE%" GEQ "3" echo Scanning sources:
if exist "%srclist_file%" DEL "%srclist_file%"
if exist "%objlist_file%" DEL "%objlist_file%"
for %%x in (%OBJ_SRC_EXTS%) do (
	set _ext_=%%x
if "%BBB_VERBOSE%" GEQ "2" echo Collecting *!_ext_!...
rem	call :exec_each "%dirlist%" "if exist src\{}\*!_ext_! dir /b src\{}\*!_ext_!"

	rem !! This + create_dirlist could be replaced with a combined routine
	rem !! that could collect both dirs and files in go of tree iteration
	rem !! (into separete results files) -- if that's actully faster, as
	rem !! this comes right after the tree scan, with a hot cache!...
	rem !! But... FOR /f or /r can only do EITHER files OR dirs, and even
	rem !! if using DIR, the results would still need to be checked for
	rem !! type after the fact! :-/ That doesn't feel like an advantage! :)
	for /r "%src_dir%" %%f in (*!_ext_!) do ( set "_f_abs_=%%f"
		set "_f_=!_f_abs_:%src_dir_abs%\=!"

		echo !_f_! | findstr /R "%UNITS_NO_COMPILE_PATTERN%" > nul
		if errorlevel 2 (
			echo - ERROR: Failed to apply filter on^: "!_f_!"^^!
			rem exit /b 1
		) else if not errorlevel 1 (
if "%BBB_VERBOSE%" GEQ "1" echo - SKIP FILE ^(%UNITS_NO_COMPILE_PATTERN%^): !_f_!
		) else (
			rem No need to quote: each item is on its own line:
			echo !_f_!>>   "%srclist_file%"
			set _obj_=!_f_:%%x=.obj!

			if defined OBJ_DIR_FLAT (
				rem `basename`...
				for %%F in ("!_obj_!") do set "_obj_=%%~nxF
			)

			echo !_obj_!>> "%objlist_file%"
if "%BBB_VERBOSE%" GEQ "2" echo + FILE:^ "!_f_!" %TAB%^(abs: "!_f_abs_!"^)
if "%BBB_VERBOSE%" GEQ "3" echo Added obj.:^   "!_obj_!"
		)
	)
rem	if errorlevel 1 exit -1
)
if "%BBB_VERBOSE%" GEQ "2" echo.


::----------------------------------------------------------------------------
:: Generate LINK/LIB dependency rules for inclusion from the main makefile...
::-----------------------------------------

	if exist "%BBB_MAKEFILE_TEMPLATE%" DEL "%BBB_MAKEFILE_TEMPLATE%"

	:: Config "glueware" to support including the makefile with adjustable
	:: parameters (e.g. for dependency queries, or real build etc.)

	::! These could in theory be just as well passed via the NMAKE command-line,
	::! but anything non-trivial, with spaces and special chars etc. is a
	::! definite *NIGHTMARE* with CMD, so better just write it as the default,
	::! and then override it from the main, pre-written (caller/driver)
	::! makefile instead!
	echo ^^!if ^^!defined^(BBB_CC_PROXY^) >> "%BBB_MAKEFILE_TEMPLATE%"
	echo BBB_CC_PROXY = @echo $$^< >>     "%BBB_MAKEFILE_TEMPLATE%"
	echo ^^!endif >>                     "%BBB_MAKEFILE_TEMPLATE%"

	echo ^^!if ^^!defined^(BBB_MAIN_TARGET^) >> "%BBB_MAKEFILE_TEMPLATE%"
	echo BBB_MAIN_TARGET = %SZ_APP_NAME%>>       "%BBB_MAKEFILE_TEMPLATE%"
	echo ^^!endif >>                            "%BBB_MAKEFILE_TEMPLATE%"

	::
	:: Main rule to trigger compilation, and then linking with a possibly slightly different obj. list...
	::
	echo BBB_build: BBB_compile_all_filtered $$^(BBB_MAIN_TARGET^) >> "%BBB_MAKEFILE_TEMPLATE%"
	echo. >> "%BBB_MAKEFILE_TEMPLATE%"

	::
	:: Phony target to trigger compilation of "compilable" objs...
	:: Note: "candidate sources" already excludes %UNITS_NO_COMPILE_PATTERN%!
	::
	echo BBB_compile_all_filtered: \>> "%BBB_MAKEFILE_TEMPLATE%"
	call :exec_each "%objlist_file%" "echo %TAB%%obj_dir%\{} \">> "%BBB_MAKEFILE_TEMPLATE%"
	echo. >> "%BBB_MAKEFILE_TEMPLATE%"

	::
	:: Rule for the main target depending on all the "linkable" objs + buildable libs...
	::
	:: (Alas, this can't be the same list as a @list file for the linker:
	:: the trailing \ for the makefile lines is unknown to the MSVC tools!)
	::
	echo $$^(BBB_MAIN_TARGET^): \>> "%BBB_MAKEFILE_TEMPLATE%"
		call :exec_each "%objlist_file%" "echo %TAB%%obj_dir%\{} \" "%UNITS_NO_LINK_PATTERN%" >> "%BBB_MAKEFILE_TEMPLATE%"
rem		call :exec_each "%liblist_file%" "echo %TAB%%lib_dir%\{} \" "%LIBS_NO_LINK_PATTERN%" >> "%BBB_MAKEFILE_TEMPLATE%"
	echo. >> "%BBB_MAKEFILE_TEMPLATE%"

	::-------------------------------------------
	:: Generate inference rules:
	::---------------------------

	echo .SUFFIXES: %OBJ_SRC_EXTS% >>  "%BBB_MAKEFILE_TEMPLATE%"

	::call :print_NMAKE_inference_rules "%OBJ_SRC_EXTS%"
	setlocal
	for %%x in (%OBJ_SRC_EXTS%) do ( set _ext_=%%x
		rem !! Can't pass the cmd arg. to print_NMAKE_inference_batch_rule if it contains spaces, because
		rem !! CMD gets confused by its own idiotic quoting rules, let alone the challenge of passing
		rem !! multi-line text, so the command block is passed via %__inference_commands__%...
		set "__inference_commands__=$$^(BBB_CC_PROXY^)"

		set _outext_=.obj
		set _outdir_=%obj_dir%

		echo.>> "%BBB_MAKEFILE_TEMPLATE%"
		echo # Inference rules for *!_ext_!...>> "%BBB_MAKEFILE_TEMPLATE%"
		echo.>> "%BBB_MAKEFILE_TEMPLATE%"
		if not _%OBJ_DIR_FLAT%_ == _1_ (
			set _outdir_=!_outdir_!\{}
		)

		set "exec_arg=call :print_NMAKE_inference_batch_rule !_ext_! !_outext_! %src_dir%\{} !_outdir_! DUMMY_CMD_PLACEHOLDER"
		rem See comments above why this (unused) DUMMY_CMD_PLACEHOLDER...

::		echo :exec_each "%dirlist_file%" "!exec_arg!"
		call :exec_each "%dirlist_file%" "!exec_arg!">> "%BBB_MAKEFILE_TEMPLATE%"


rem Single-file C++ modules (.ixx) need rules for both their .ifc and .obj, to keep MAKE happy:
		if "!_ext_!" == ".ixx" (
			set _outext_=.ifc
			set _outdir_=%IFC_ROOT%
			set "exec_arg=call :print_NMAKE_inference_batch_rule !_ext_! !_outext_! %src_dir%\{} !_outdir_! DUMMY_CMD_PLACEHOLDER"
			rem See comments above why this (unused) DUMMY_CMD_PLACEHOLDER...
			call :exec_each "%dirlist_file%" "!exec_arg!">> "%BBB_MAKEFILE_TEMPLATE%"
		)
	)

	endlocal

:skip_configure


::=====================================================================================
::=====================================================================================
::=====================================================================================
::
::   NOW, READY TO RUN THE BUILD...
::
::=====================================================================================
::=====================================================================================
::===================================================================================
if %BBB_SKIP_BUILD% EQU 1 goto :skip_build


::!!HACK: Add an empty line if more details may have beeb printed above...:
if "%BBB_VERBOSE%" GEQ "2" echo.
if "%BBB_VERBOSE%" GEQ "1" echo Building...
:: Add an empty line if more details are expected:
if "%BBB_VERBOSE%" GEQ "2" echo.

::For testing:
::(call :get_changed_sources "%srclist_file%") && type "%srclist_file%" && exit

::
:: Create target dirs for the handicapped MSVC tools...
::
::!! Should go in the makefile!...
::!! But calling this one (for tree mode) from there would be another nightmare:
:: For tree-modes:
::call :exec_each  "%dirlist_file%" "if not exist %OBJ_ROOT%\{} md %OBJ_ROOT%\{}"

if not exist %IFC_ROOT% md %IFC_ROOT%
if not exist %OBJ_ROOT% md %OBJ_ROOT%

if "%BATCH_COMPILE%"=="on" (
	set "nmake_batch_switch="
	if "%BBB_VERBOSE%" GEQ "2" echo Batch-compiling: on
) else (
	set "nmake_batch_switch=/Y"
	if "%BBB_VERBOSE%" GEQ "2" echo Batch-compiling: off
)

if exist "%BBB_MAIN_MAKEFILE%" (
	%BBB_NMAKE_RECURSE_CMD% %nmake_batch_switch% BBB_build
:: These are critical here, actually: the fallthrough path DID lose the fckn ERRORLEVEL! :-o
	IF ERRORLEVEL 2 EXIT 2
	IF ERRORLEVEL 1 EXIT 1

) else (
	echo - ERROR: Makefile "%BBB_MAIN_MAKEFILE%" could not be found^!
)

:skip_build

goto :eof



:: OPTIONAL:
::----------------------------------------------------------------------------
:get_changed_sources
::
:: Use the BBB_MAKEFILE_TEMPLATE to get the list of newly touched sources
::
:: IN   listfile
::
	set "listfile=%~1"

	:: Replace the list of sources with the changed ones:
	call :empty_file "%srclist_file%"
	::NOTE:: /C required for silencing it when "target is up-to-date", and
	::       /Y for disabling batch mode (just to ensure one file per line):
	::       (Also, BBB_NMAKE_RECURSE_CMD is NOT to be used here!)
	nmake /nologo /c /y /f %BBB_MAKEFILE_TEMPLATE% >> "%listfile%"
	if errorlevel 1 exit 1
	goto :eof


::!!!--------------------------------------------------------------------------------
::!!! OBSOLETE MONKEYING BELOW:
::!!!
::
:: Prepare linker-ready obj list: prepend the obj dir
::
::!! Should go to the tmp. makefile too, as a linker rule, which could then just be
::!! included by the main makefile (similarly to the Jumpstart rule generation stuff)!
::
set "linker_objlist_file=%OBJ_ROOT%\linkable_objects.tmp"
call :exec_each "%objlist_file%" "echo %TAB%%obj_dir%\{}" "%UNITS_NO_LINK_PATTERN%"> "%linker_objlist_file%"

goto :eof
::!!!--------------------------------------------------------------------------------



::=====================================================================================
:setd
:: Set a variable to a value, or if that's empty (or ""), then to a default (if one is
:: provided).
::
:: The intended use case is sanitizing arguments like
::
::	call :setd var %1 default
:: or
::	call :setd var %~1 default
:: or
::	call :setd var "%~1" default
:: or
::	call :setd var default
::
:: OUT  %1: name of variabla to set
:: IN   %2: value to set, or default to set if !%1! is empty
:: IN   %3: default value, if %2 is "" (or other placeholder for an empty value)
::
::echo - setd: 1 = [%1]
::echo - setd: 2 = [%2]
::echo - setd: 3 = [%3]
	if _%2_ == __ exit /b 1 &rem Neither main nor default value! :-o
	:: If there ar 3 args, then set the second first
	if not "%~3" == "" (
		set "%1=%~2"
		if "%~2" == "" set "%1=%~3"
	) else (
		if _!%1!_ == __ set "%1=%~2"
	)
::echo - setd: %1 = [!%1!]
	goto :eof

:_setd_test
	setlocal
	(call :setd) || echo 1: ERROR if no args
	(call :setd var) || echo 2: ERROR, still, if not enough args (only a var name)
	(call :setd var 1) && echo 3: [!var!] should be 1
	(call :setd var 2) && echo 4: [!var!] should still be 1
	(call :setd var 2 3) && echo 5: [!var!] should be 2
	(call :setd var "" %var%) && echo 6: [!var!] should still be 2
	(call :setd new "") && echo 7: [!new!] should be empty
	(call :setd new 3) && echo 8: [!new!] should be 3
	(set "var=")
	(call :setd var "" "") && echo 9: [!var!] should be empty

	:: Regressions...

	set _BBB_VERBOSE=3
	(call :setd _BBB_VERBOSE "%1") && echo 10: [!_BBB_VERBOSE!] should be 3
	(call :setd _BBB_VERBOSE 1) && echo 11: [!_BBB_VERBOSE!] should still be 3

	(call :setd var ".ixx .c .cpp .cc") && echo 12: [!var!] should be [.ixx .c .cpp .cc]

	endlocal
	exit /b


::-------------------------------------------------------------------------------------
:check_dir
::
:: IN   %1: dir path (default: .)
:: OUT  %2: name of variabla in which to return the abs. path of dir (optional)
::
::!!Sigh...	setlocal
	call :setd _dir_ "%~1" .

::echo check_dir: 1 = [%1]
::echo check_dir: quoted ~1 = ["%~1"]
::echo check_dir: _dir_ = [%_dir_%]

	set "_retvar_=%~2"
	pushd "%_dir_%" 2> nul
	if errorlevel 1 (
rem Don't spoil the client's output! :-o
rem		echo - WARNING: Can't use dir: "!_dir_!" ^(from !CD!^)
		exit /b 1
	)
	if not "" == "%_retvar_%" set "%_retvar_%=%CD%"
	set _dir_=
	set _retvar_=
	popd
	exit /b
::!!Sigh...:
	if not "" == "%_retvar_%" (
echo wtf
		endlocal & set "!_retvar_!=!CD!"
echo above
	) else (
		endlocal
	)
	popd
	goto :eof

::-------------------------------------------------------------------------------------
:empty_file
:: (Re)create file as empty
::
:: IN   %1: file path
::
	< nul set /p "=" > "%~1"
	goto :eof

::-------------------------------------------------------------------------------------
:check_file_empty
::
:: Returns errorlevel 0 if empty otherwise 1 (so && on the call should work)
::
:: IN   %1: file path
::
	if not exist "%~1" (
		exit /b 1
	) else if %~z1 equ 0 (
		exit /b 0
	) else (
		exit /b 1
	)
	goto :eof

::-------------------------------------------------------------------------------------
:addslash
::
:: Append backslash to a path "in a sensible manner"...
::
:: OUT  %1: variable name in which to return the result (or do nothing if empty)
:: IN   %2: dir path
::
:: If the path has a slash already, none is added.
:: If it's empty (or ""), or ends with a colon (i.e. likely a drive's current dir),
:: .\ is appended instead.
:: If no path is specified, the one in the named variable is used.
::
::!! Sigh, this would prevent setting the result var, too! :)
::!!	setlocal
	if _%~1_ == __ exit /b 1
	set "_result_var_=%~1"
	call :setd _path_ "%~2" "!%~1!"

	:: This would fail if the path was quoted, so the unquoting at init is crucial!
	set "_eos_=!_path_:~-1!"
	if        _%_eos_%_ == _\_ (
		set "%_result_var_%=%_path_%"
	) else if _%_eos_%_ == _/_ (
		set "%_result_var_%=%_path_%"
	) else if _%_eos_%_ == _:_ (
		set "%_result_var_%=%_path_%.\"
	) else if _%_path_%_ == __ (
		set "%_result_var_%=%_path_%.\"
	) else (
		set "%_result_var_%=%_path_%\"
	)
::!!	endlocal
	set _eos_=
	set _path_=
	set _result_var_=
	goto :eof

:_addslash_test
	setlocal
	(call :addslash) || echo Should be ERROR: no return var! (OK, if you see this line.)
	(call :addslash res)  && echo Should be .\   [!res!]
	call :addslash res "" && echo Should be .\   [!res!]
	call :addslash res ./ && echo Should be ./   [!res!]
	call :addslash res X: && echo Should be X:.\ [!res!]
	:: Use the var in-place
	(call :addslash res) && echo Should be X:.\ [!res!]
	set res=
	call :addslash res && echo Should be .\ [!res!]
	endlocal
	exit /b

::-------------------------------------------------------------------------------------
:create_dirlist
::
:: Create a (filtered) list of (sub)directories of a tree
::
:: IN   %1: dir-list filename (default: .dirlist.tmp)
:: IN   %2: tree root dir (default: .)
:: IN   %3: include_patterns: only add dirs that have matching filenames (default: *)
:: IN   %4: exclude_patterns (default: none)
::
	setlocal
	set "dirlistfile=%~1" && if not defined dirlistfile set "dirlistfile=.dirlist.tmp"
	set "root=%~2"        && if not defined root        set "root=."
	call :setd include_patterns "%~3" *
	set "exclude_patterns=%~4"
	set "tempfile=.tempfile.tmp"
	set "TAB=	"

	:: To overcome some additional CMD stupidity, we must turn include_patterns
	:: from a space-separated list to multi-line... (Otherwise FOR would insist
	:: on expanding wildcards etc.)
	set _include_patterns_ml=%include_patterns: =!LF!%

::echo include_patterns = [%include_patterns%]

	pushd "%root%"
		set root_abspath=%CD%\
		rem Fix double \\ in case of X:\
		set "root_abspath=!root_abspath:\\=\!"
	popd
if "%BBB_VERBOSE%" GEQ "3" echo Scanning tree: %root_abspath%

	rem Create the list file...
	rem The first empty line is significant: it's for the root of %root%!
	rem (Clients can decide to easily ignore it, or use as "" or . for the tree root.)
	echo. > %dirlistfile%
:: Except... The counterpart for loops in CMD are too happy to ignore that line altogether. :-/
:: So...:
::!!??	echo . > %dirlistfile%

	for /d /r "%root_abspath%" %%d in (*) do ( set "_dir_abs_=%%d"
rem Or:	for /f "delims=" %%d in ('dir /s /b /a:d "%root_abspath%"') do (
if "%BBB_VERBOSE%" GEQ "3" echo Considering dir^: "!_dir_!" %TAB%^(abs: "!_dir_abs_!"^)
		set "_dir_=!_dir_abs_:%root_abspath%=!"

		rem ! Pathname filtering should be done before dir content globbing, but that
		rem ! would involve calling `findstr` for each name, which is way too heavy!... :-/
		rem !! Also, the non-emptiness of the excl. pattern must also be checked,
		rem !! complicating the lame ifs into an even more annoyig level...
		rem echo !_dir_! | findstr /R "%exclude_patterns%" > NUL
		rem if not errorlevel 1 (
		if 1==0 (
if "%BBB_VERBOSE%" GEQ "2" echo - DIR: !_dir_! ^(filtered^)
		) else (
			set "_has_src_="
			for /f %%p in ("!_include_patterns_ml!") do ( set _fn_pattern_=%%p
				if "!_has_src_!"=="" (
if "%BBB_VERBOSE%" GEQ "4" echo - no matching files yet, trying: "!_dir_abs_!\!_fn_pattern_!"...
					if exist "!_dir_abs_!\%%p" (
if "%BBB_VERBOSE%" GEQ "2" echo + TAKE DIR: "!_dir_!"
						set "_has_src_=1"
						echo !_dir_!>> %dirlistfile%
						rem break; // alas, no such thing...
					)
				)
			)
			if "!_has_src_!"=="" (
if "%BBB_VERBOSE%" GEQ "2" echo - SKIP DIR: "!_dir_!" ^(has no %include_patterns%^)
			)
		)
	)

	if not "%exclude_patterns%" == "" (
		findstr /V /R "%exclude_patterns%" "%dirlistfile%" > "%tempfile%"
		if errorlevel 2 (
			echo - ERROR: Failed to apply filter to "%dirlistfile%"^^!
			exit /b 1
		) else if not errorlevel 1 (
			rem Some filtering occurred, report...
if "%BBB_VERBOSE%" GEQ "1" (
			for /f %%d in ('findstr /R "%exclude_patterns%" "%dirlistfile%"') do (
				set "xlist=!xlist!, %%d"
				rem Quoting looked noisy & we have the comma anyway:
				rem set "xlist=!xlist!, ^"%%d^""
			)
			if defined xlist (
				set "xlist=!xlist:~2!" &rem Remove leading sep.
if "%BBB_VERBOSE%" GEQ "1"		echo - SKIP DIR^(S^) ^(%exclude_patterns%^): !xlist!
			)
)
			move /y "%tempfile%" "%dirlistfile%" > nul
			if errorlevel 1 echo - ERROR: Failed to move temp. file "%tempfile%"
		)
	)
	endlocal
	goto :eof

::-------------------------------------------------------------------------------------
:exec_each
::
:: Apply (templated) command to each line of a list file
::
:: IN  %1: input list filename
:: IN  %2: command template, where each {} is replaced with the current line of the input list
:: IN  %3: exclude patterns, like with create_dirlist
::
:: E.g. to print each line of the input: exec_each listfile "echo {}"
::
	setlocal
	set "listfile=%~1"
	set "cmd=%~2"
	set "exclude_patterns=%~3"

	if "%cmd%" == "" exit /b

	if exist "%listfile%" for /f "tokens=*" %%f in (%listfile%) do ( set "_f_=%%f"
		set _skip_=
		if not "%exclude_patterns%" == "" (
			echo !_f_! | findstr /R "%exclude_patterns%" > nul
			if errorlevel 2 (
				echo - ERROR: Failed to apply filter to^: "!_f_!"^^! >&2
				rem exit /b 1
			) else if not errorlevel 1 (
if "%BBB_VERBOSE%" GEQ "2" echo - SKIP: !_f_! ^(matching %exclude_patterns%^) >&2
				set _skip_=1
			)
		)
		if not defined _skip_ %cmd:{}=!_f_!%
	)
	endlocal
	goto :eof

::-------------------------------------------------------------------------------------
:print_NMAKE_inference_batch_rule
::
:: IN   %1: source ext. (with the . prefix)
:: IN   %2: target ext. (with the . prefix)
:: IN   %3: source dir path
:: IN   %4: target dir path
:: IN   %5: command block
::
	setlocal
	set "_inext_=%~1"
	set "_outext_=%~2"
	set "_inpath_=%~3"
	set "_outpath_=%~4"
	rem Can't shift for %* :-/ Use it as-is, no unquoting:
::!! Yeah, no...: set "_cmd_=%5%6%7%8%9"
	set "_cmd_=%__inference_commands__%"
	set "TAB=	"

	::!! This should be done by the caller, via exec_each ..., not here!...
	set "_cmd_=!__inference_commands__:{}=%_outpath_%!"

	echo {%_inpath_%}%_inext_%{%_outpath_%}%_outext_%::
	if not "%_cmd_%" == "" (
		echo %TAB%%_cmd_%
	) else (
		echo EMPTY
	)

	endlocal
	goto :eof
<<keep


#!! Kludge until I find out the correct way:
#!! Also done manually, coz no way to track the actual deps automatically...:
OON_CPP_MODULE_IFCS=\
	$(ifc_dir)/Storage.ifc 


#-----------------------------------------------------------------------------
# LEGACY Workflow Control Rules (UNUSED, only for reference!)
#-----------------------------------------------------------------------------

mainlib_rules_inc=$(out_dir)\main_lib_rules.inc
mainexe_rules_inc=$(out_dir)\main_exe_rules.inc

!if "$(main_lib)" != ""
mk_mainlib_objdep_inc: "$(obj_dir)"
	@cmd /v:on /c <<$(out_dir)\mklibrules.cmd
	@echo off
        for %%x in ($(obj_source_exts)) do (
		set "_ext_=%%x"
		for /r "$(src_dir)\$(lib_src_subdir)" %%o in ($(UNITS_PATTERN).!_ext_!) do (
			set "_o_=%%o"
			echo !_o_! | findstr /R "$(UNITS_NO_LIB_PATTERN)" > nul
			if not errorlevel 1 (
				if "$(BBB_VERBOSE)" GEQ "1" echo - EXCLUDE FROM LIB: !_o_!
			) else (
				set "_o_=!_o_:$(src_dir_abspath)\=!"
				for %%x in ($(obj_source_exts)) do (
					set "_o_=!_o_:.%%x=.obj!"
				)
				set "objlist=!objlist! $(obj_dir)\!_o_!"
			)
		)
	)
	echo !objlist! > $(obj_list_file)
	set "_TAB_=	"
	echo $(main_lib): !objlist!               >  $(mainlib_rules_inc)
	rem echo %_TAB_%Creating lib: $$@...      >> $(mainlib_rules_inc)
	rem echo %_TAB_%lib -nologo -out:$$@ $$** >> $(mainlib_rules_inc)
<<keep
!else
mk_mainlib_objdep_inc:
!endif
!if "$(main_exe)" != ""
mk_mainexe_objdep_inc: "$(obj_dir)"
	@cmd /v:on /c <<$(out_dir)\mkexerules.cmd
	@echo off
        for %%x in ($(obj_source_exts)) do (
		set "_ext_=%%x"
		for /r "$(src_dir)\$(lib_src_subdir)" %%o in ($(UNITS_PATTERN).!_ext_!) do (
			set "_o_=%%o"
			echo !_o_! | findstr /R "$(UNITS_NO_LINK_PATTERN)" > nul
			if not errorlevel 1 (
				if "$(BBB_VERBOSE)" GEQ "1" echo - EXCLUDE FROM AUTO-LINK: !_o_!
			) else (
				set "_o_=!_o_:$(src_dir_abspath)\=!"
				for %%x in ($(obj_source_exts)) do (
					set "_o_=!_o_:.%%x=.obj!"
				)
				set "objlist=!objlist!$(obj_dir)\!_o_! "
			)
		)
	)
	echo !objlist! > $(obj_list_file)
	rem No use even for this as a deps hack, as it's included only in the post-dirwalk final round, with no proper comp. context:
	rem echo !objlist!: $(OBJ_DEPS_manually) ^>  $(mainexe_rules_inc)
	rem And this is bad, too, as by the time of linking there's no way back to seeing the whole tree and do inferencing...
	rem echo $(main_exe): !objlist! > $(mainexe_rules_inc)
	echo #!!  > $(mainexe_rules_inc)
	echo #!! Make a rule file with inference rules for each subdir instead!... >> $(mainexe_rules_inc)
	echo #!! >> $(mainexe_rules_inc)
<<keep
!else
mk_mainexe_objdep_inc:
!endif

clean:
# Cleans only the target tree of the current build alternative!
# And no way I'd just let loose a blanket RD /S /Q "$(out_dir)"!...
	@if not "$(abspath $(obj_dir))" == "$(abspath .\$(obj_dir))" echo - ERROR: Invalid object dir path: "$(obj_dir)" && exit -1
# Stop listing all the deleted .obj files despite /q -> cmd /e:off (self-explanatory, right?)
	@if exist "$(obj_dir)\*.obj" cmd /e:off /c del /s /q "$(obj_dir)\*.obj"
	@if exist "$(obj_list_file)" cmd /e:off /c del $(obj_list_file)
# To let the idiotic tools run at least, the dir must exist, so if it was deleted
# in a previous run, we must recreate it just to be able to check and then delete
# it right away again... Otherwise: "The system cannot find the file specified."):
	@if not exist "$(obj_dir)" mkdir "$(obj_dir)"
	@dir "$(obj_dir)" /s /b /a:-d 2>nul || rd /s /q "$(obj_dir)"
# Delete the main targets (lib/exe) separately, as they may be outside the tree:
	@for %f in ($(build)) do @if exist "%f" del "%f"
# Delete some other cruft, too:
	@del "$(out_dir)\*.pdb" "$(out_dir)\*.idb" "$(out_dir)\*.ilk" 2>nul
	@if exist "$(mainlib_rule_inc)" del "$(mainlib_rule_inc)"

clean_all:
	@if not "$(abspath $(out_dir))" == "$(abspath .\$(out_dir))" echo - ERROR: Invalid output dir path: "$(out_dir)" && exit -1
# RD will ask...:
# - But to let the idiotic tools run at least, the dir must exist, so if it was deleted
# in a previous run, we must recreate it just to be able to check and then delete it
# right away again... Otherwise: "The system cannot find the file specified."):
	@if not exist "$(out_dir)" mkdir "$(out_dir)"
	@if not "$(abspath $(out_dir))" == "$(abspath .)" @rd /s "$(out_dir)"
# Delete the libs/exes separately, as they may be off-tree:
	@if exist "$(main_lib)" del "$(main_lib)"
	@if exist "$(main_exe)" del "$(main_exe)"
#!!Still can't do the entire "matrix" tho! :-/ (Behold the freakish triple quotes here! ;) )
	@$(ECHO) - NOTE: Some build targets may still have been left around, if they are not in """$(out_dir)""".


#-----------------------------------------------------------------------------
# Actual ("low-level") build jobs...
#-----------------------------------------------------------------------------

# Dependency rules for the main lib/exe
## Sorry, no autodeps.; see at the compile_dir: rule!
### OON legacy: $(OBJS) $(CPP_MODULE_IFCS): $(INCLUDES) $(CPP_MODULE_SOURCES)


#------------------------
# Build the "main" lib
#------
!if "$(main_lib)" != ""
!ifdef RECURSED_FOR_FINISHING
!include $(mainlib_rules_inc)
!endif
#! Exploiting the fact that single-: rules are combined, so the deps. are in the include,
#! and the commands can be here, while still considering the dependencies:
$(main_lib):
	@$(ECHO) Creating lib: $@...
#!!Add BBB_VERBOSE support, but not with !if, but a $(mute)=@ cond. macro:
	lib -nologo -out:$@ $**
!endif

#-----------------------------------------------------------------------------
# Some auto-remake support (-- the rest is in the OON build script!)
# Changing the makefile triggers a full rebuild.
#!! I'm sure there's a better way for this, but for now:
OON_FULL_REBUILD_BY_MANUAL_DEPS=$(OON_CPP_MODULE_IFCS)

#!ifdef SRC_EXT_
#!! I seriously don't understand why this nonsense is actually needed to trigger a full recomp.!
#!! It's adding /some of/ the /sources/ (of the current dir run) to the targets, right?! :-o
#!! Why is it even not a "dunno how to make" error?!
#OON_FULL_REBUILD_BY_MANUAL_DEPS=$(OON_FULL_REBUILD_BY_MANUAL_DEPS) $(src_dir)\$(UNITS_PATTERN).$(SRC_EXT_)
#!endif

#!!$(OON_FULL_REBUILD_BY_MANUAL_DEPS): $(THIS_MAKEFILE)

#-----------------------------------------------------------------------------
# Custom build steps...
#-----------------------------------------------------------------------------
#!! Not `$(obj_dir)\app\main.obj: ...` in the flattened tree mode!
$(obj_dir)\main.obj: $(COMMIT_HASH_INCLUDE_FILE)

!if defined(COMMIT_HASH_INCLUDE_FILE)
$(COMMIT_HASH_INCLUDE_FILE):
#	Using sh's echo explicitly, as this block is about calling an .sh script:
	@$(SH) -c "echo 	Make last commit ID available for \#including..."
	$(_mute)$(SH) "tooling/git/_create_commit_hash_include_file.sh"
	@$(SH) -c echo
!else
!message -ERROR: COMMIT_HASH_INCLUDE_FILE not defined. Env setup not run?
!endif


#=============================================================================
#!!
#!! Things below should be generated by the BBild script! (Yes, in addition
#!! to the previously generated interim makefile for dependencies + inference!)
#!!

BBB_MKDIR_CMD=@if %BBB_VERBOSE% GEQ 4 ($(ECHO) Creating dir: $@) && if not exist $@ @md $@

# Set build params (main target name, per-file inference command to compiling etc.)...
BBB_CC_PROXY = $(_mute)$(CXX) $(CFLAGS) $(CXXFLAGS) -ifcOutput $(ifc_dir)\ -Fo$(OBJ_DIR_) $<

!if "$(main_exe)" != ""
BBB_MAIN_TARGET = $(main_exe)
#!message BBB_MAIN_TARGET = $(BBB_MAIN_TARGET)
!endif

BBB_build: BBB_init BBB_main

BBB_init: BBB_mk_output_dirs

BBB_mk_output_dirs: "$(obj_dir)" "$(ifc_dir)" "$(lib_dir)" "$(exe_dir)"
#	Use the "familiar" dir vars we've set here in the makefile,
#	not the ones used in the script (except those created there)!
	@if %BBB_VERBOSE% GEQ 3 $(ECHO) Pre-created missing target directories.

#! Double :: for MAKE to go easy if some are the same!... Unfortunately, that
#! also means giving up the very reason of getting it done by MAKE: the auto
#! existence checking... :/
#! Another con against using MAKE for this: can't output a nice diag. msg. with
#! symbolic (macro name) tags (or anything) without giving up even more D.R.Y.:
"$(ifc_dir)"::
	$(BBB_MKDIR_CMD)
"$(lib_dir)"::
	$(BBB_MKDIR_CMD)
"$(exe_dir)"::
	$(BBB_MKDIR_CMD)
#!! This will need to be taken care of at the inference rules in TREE_MODE,
#!! so each subdir gets created. (In non-batch mode it'll hapen for each file, but no harm done...)
"$(obj_dir)"::
	$(BBB_MKDIR_CMD)

#!! Old-style, less verbose, more D.R.Y., but also less flexible and "makey":
#BBB_mk_output_dirs: # Pre-create the output dirs, as MSVC can't be bothered...
#	@if %BBB_VERBOSE% GEQ 3 $(ECHO) Creating target directories (if missing)...
##	Use the "familiar" dir vars we've set here in the makefile,
##	not the ones used in the script (except those created there)!
#	@if not exist "$(out_dir)" md "$(out_dir)"
#	@if not exist "$(lib_dir)" md "$(lib_dir)"
#	@if not exist "$(exe_dir)" md "$(exe_dir)"
#	@if not exist "$(ifc_dir)" md "$(ifc_dir)"
##!!	This will need to be taken care of at the inference rules in TREE_MODE,
##!!	so each subdir gets created. (In non-batch mode it'll hapen for each file, but no harm done...)
#	@if not exist "$(obj_dir)" md "$(obj_dir)"

BBB_main: cpp_mod_ifcs $(BBB_MAIN_TARGET)  # See #45 for cpp_mod_ifcs!

cpp_mod_ifcs: "$(obj_dir)" $(OON_CPP_MODULE_IFCS)
#!! This doesn't have any modules-specific subdir (pre-creation) support yet,
#!! so actually setting the modules dirs to anything would fail the 1st time!
#!! (Even interface-only ones seem to generate .obj files, at least with MSVC!)



#----------------------------------
# Include the autogenerated rules
#------
# This *must* come after the default target has been defined above!
#!message include: $(BBB_MAKEFILE_TEMPLATE)
!ifdef BBB_MAKEFILE_TEMPLATE
!include $(BBB_MAKEFILE_TEMPLATE)
!endif


#------------------------
# Build the "main" exe
#------
!if "$(main_exe)" != ""
#! See at main_lib: about implicitly combining the included deps.!
#! NOTE: works only because $(BBB_MAKEFILE_TEMPLATE) has been included above
#!message main_exe: $(main_exe)
$(main_exe): $(EXT_LIB_SFW) $(EXT_LIB_ZSTD)
#$(main_exe): $(obj_dir)\main.obj $(main_lib)
	@if %BBB_VERBOSE% GEQ 2 $(ECHO) Creating executable: $@...
#	@if %BBB_VERBOSE% GEQ 4 $(ECHO) Creating executable `$@` from $**
#!!Add better VERBOSE support to this, too:
	$(_mute)link -nologo $(LINKFLAGS) -out:$@ $** $(main_lib) $(EXT_LIBS)
!endif
